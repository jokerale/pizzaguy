\documentclass[10pt]{article}

\usepackage[
    style=numeric,%alphabetic, 
    backend=bibtex,
    sorting=none
    ]{biblatex}
\bibliography{refs}{}


\title{Pizza Guy}
\date{\today}
\author{Giacomo Boldini, Alessio Diana, Federica Zaglio}

\usepackage{hyperref}
\usepackage{cleveref}

\begin{document}

	\maketitle

	\begin{abstract}

		In this report, we will describe the Pizza Guy project. This project 
		aims to find the best possible schedule of a set of orders that
		minimizes the distance travelled by the deliverers in a evening of 
		work. Our solution is developed using a CLP(FD) model and implemented 
		in MiniZinc. All the remaing part of the project(data retrieving, cleaning
		and visualization) are done using Python.\\	
		In the \cref{Assignment} we will describe the problem and the goal
		we want to reach, in the \cref{Model} we will the describe the 
		model and the implementation, including some euristichs and symmetry breaking
		strategies. In the \cref{Results} we will describe the results and
		the possible search strategies. In the last \cref{Future work} we 
		will propose some possible changes and improvements to the current model.
		
	\end{abstract}

	\tableofcontents

	\pagebreak

	\section{Assignment}
	\label{Assignment}
	The main problem we want to solve can be described as follow: there is a pizzeria in the 
	town that delivers pizzas at home; we want to find the best schedule of the set of orders 
	(for a single evening) that minimize the total travelled distance by the deliverers 
	respecting the delivery times requested by the customer.
	
	The assignment gives us the following informations about the problem:
	\begin{enumerate}
		\item an order consists of:
		\begin{enumerate}
			\item a delivery address;
			\item a desired delivery time;
			\item a number of pizzas;
		\end{enumerate}
		\item the desired delivery time has a granularity of 15 minutes (from 
			19.00 to 22.00);
		\item the delivery window is up to 30 minutes later than desired delivery 
			time;
		\item the street topology of the city can be seen as a graph: the nodes represent
			the addresses and they are connected by edges that contain travel time 
			between nodes; so, we know the distance between each pair of addresses
			in the town;
		\item every deliverer can carry at most 16 pizzas;
		\item multiple travels from and to the pizzeria are allowed even in the 
			delivery window.
	\end{enumerate}

	\subsection{Goal}

	The goals of this work are:
	\begin{enumerate}
		\item write a program that solves the problem (in MiniZinc);
		\item write a benchmark suite using 5 different towns of increasing size
			and 10 input sets for each one; the input sets must enforce that all
			the deliverers do at least two travels;
		\item on one configuration that runs in a couple of minutes, try
			different search strategies and then use the most promising one to solve a
			difficult input set.
	\end{enumerate}

	\section{Model}
	\label{Model}

	%file: \texttt{an-idea-2.mzn}\\~\
	
	\subsection{Input data}

	\paragraph*{}
	The input consists in having:
	\begin{enumerate}
		\item $d$: the number of deliverers available
		\item $mdist$: the 2-d matrix representing the travel distance between
			every node in the graph generated using Dijkstra (including those
			that are not a destination)
		\item $k$: the side dimension of $mdist$
		\item a set of $N$ orders specifing the destination $dest$, the delivery 
			time $orario$ and the number of pizzas $num\_pizzas$
			%TODO: cambiare il nome della struttura dati "ORARIO"
	\end{enumerate}

	\subsection{Assumptions}
	In order to make the problem a little easier, we made the following 
	semplifications:
	\begin{enumerate}
		\item the graph is undirected so \texttt{mdist}	is symmetric and 
			\texttt{mdist[x, y] = mdist[y, x]}
		\item a deliverer can do only a single travel in one half-an-hour. In other
			words, the orders that are assigned to him/her are delivered creating 
			a circuit starting from the pizzeria, visiting all the destinations 
			and ending in the pizzeria
	\end{enumerate}

	\subsection{Implementation}


	\textbf{TODO:} 
	\begin{itemize}
		\item Scrivere di sched, P, dist che hanno le stesse pos valorizzate.
		\item Def. da minizinc
		\item Spiegare che tante cose servono per semplificare i calcoli
	\end{itemize}
	
	The time is divided in 6 slots of half-an-hour (19.00 - 22.00). Let's call
	$h$ one of these slots of time.
	There are $d$ deliverers available for doing deliveries.
	Each deliverer, $d$, has a set of orders to handle for each slot of time $h$.

    \paragraph*{Scheduling}
	These informations are stored in a boolean 3-d matrix called 
	\texttt{scheduling} in which: 
	
	\begin{center}
		\texttt{scheduling[$d$, orderID, $h$] = true}
	\end{center}
	
	means that the deliverer $d$ has to deliver the order with id 
	\texttt{orderID} in the time slot $h$. In every slot $h$, the deliverer must 
	reach all nodes specified as \textit{destinations} of the orders assigned to 
	him/her, starting from node $1$ (pizzeria) and returning back to it. This creates
	 a sort of "circuit" starting and ending with the same node, that reaches all the 
	nodes specified in a matrix row).

	Obviously, one order can be delivered only once during the evening by only
	one deliverer, in the delivery window computed from the requested time.

	\begin{center}
		\texttt{array[1..d, 1..N, 1..h] of var bool: scheduling;}
	\end{center}

	\paragraph*{Pizzas\_carried}
	During the evening there are $N$ orders to be delivered, each of which is made of
	16 pizzas at most. This ensure that we need only a deliverer to deliver the 
	entire order.
	Since we can deliver more than one order in a single travel, we need to
	record the total number of pizzas that a deliverer has in his/her bag.
	To do this, we use a 2-d matrix called \texttt{pizzas\_carried} where
	the first dimension represents the deliverer $d$ and the second 
	represents the half-an-hour $h$ considered.


	\begin{center}
		\texttt{array[1..d, 1..h] of var 0..16: pizzas\_carried;}
	\end{center}

	\paragraph*{Ea - Estimated arrival}
	In order to ensure that all deliveries arrive in time, we use \texttt{ea} which
	stands for estimated arrival. This array contains, for every order, the arrival 
	time, in minutes, from the starting time (19.00). At every order, we sum the number 
	of minutes that must pass before the delivery take place, so doing this way,
	we are sure that the delivery is done in the right delivery window.
	For example, if the delivery is requested for 20.00, if the destination is five minutes 
	far from the pizzeria and no other delivery is made before that, we will sum 60 to 
	be sure about the right delivery window and 5 for the travel time. So the \texttt{ea}
	for this delivery will be 65.
	
	\begin{center}
		\texttt{array[1..N] of var 0..h*30: ea;}
	\end{center}
	

	\paragraph*{P} The main goal of the project is to minimize the travel distance 
	covered by all the deliverers in the evening. To do so, a possible strategy
	is to deliver more than one delivery in a single travel. This is convenient 
	if the deliveries are made in a way that minimize the distance travelled between the nodes.
	To encode this information, we use \texttt{P}, which is a 3-d matrix that stores
	all the nodes that every deliverer has to visit in one travel. 

	\begin{center}
		\texttt{array[1..d, 1..N, 1..h] of var array2set(dest) union {0}: P;}
	\end{center}
	%The useful thing
	%about this matrix is that it allows us to control the order of each delivery made 
	%by every deliverer in one travel and compute the travel distance.
	
	\paragraph*{X} This 3-d matrix is used to support the creation of all the other 
	constraints, making the computation of the distances easier.
	In this matrix, meangingful \textit{positions} of the matrix $P$ are stored for each 
	$d$ and $h$. Each row contains the positions of the matrix P (destination nodes) 
	that $d$ deliverer has to reach in the $h$ half-an-hour. This matrix allows 
	us to control the order of each delivery made by every deliverer in one travel
	and, as consequence, compute the corresponding travel distances (stored in $distances$).

	\begin{center}
		\texttt{array[1..d, 1..N, 1..h] of var 0..N: X;}
	\end{center}
	% magari un esempio non sarebbe male

	\paragraph*{Distances}
	Using the data structures seen before, we use this 3-d matrix to store all
	the partial distances needed to reach every delivery node. Using this matrix we can 
	enforce that all the deliveries are delivered in time and, since we want to minimize 
	the travel distance, it allows us to combine deliveries that belongs to different
	time slots (eg. 19.15 and 19.30) but only if they are adjacent because of the maximum 
	delivery time of 30 minutes.

	\begin{center}
		\texttt{array[1..d, 1..N, 1..h] of var 0..29: distances;}
	\end{center}

	\paragraph*{}
	The matrices $scheduling$, $P$ and $distances$ are strictly related to each other.
	They encode the same concept but using different informations. First of
	all they have the same sizes \texttt{[1..d,1..N,1..h]} and if one cell is meaningful in
	one	of them, it is also meaningful in the others.
	In particular, in a position 
	\texttt{[id,iN,ih]}:
	\begin{itemize}
		\item \textit{sheduling = 1} means that the order \textit{iN} has to be
		accomplished by the deliverer \texttt{id} in the \texttt{ih} half-an-hour;
		\item \textit{P = n} means that the order \textit{iN} has to be
		accomplished by the deliverer \texttt{id} in the \texttt{ih} half-an-hour 
		reaching the node \texttt{n} in the graph
		\item \textit{distances = l} means that the order \texttt{iN} has to be
		accomplished by the deliverer \texttt{id} in the \texttt{ih} half-an-hour 
		and it will take \texttt{l} minutes to reach it, starting from the beginning of the
		corresponding half-an-hour (partial time) 
		 
	\end{itemize}
	All the others meaningless positions are set to zero in all the matrices.

	\paragraph*{Total\_travel}
	We use this 2D matrix, in order to store the total travel distance of deliverer \textit{id} in one half-an-hour \textit{ih}.
	As describe above, in the matrix \textit{distance} there are partial distances: from pizzeria to first delivery node, 
	from first delivery node and the second one and so on until the last delivery node.
	If we add the distance between this last delivery node and the pizzeria (that is the path to return to the pizzeria)
	we have the total travel distance.
	As already mentioned, our goal is minimize this value.

	\begin{center}
		\texttt{array[1..d, 1..h] of var 0..29: total\_travel;}
	\end{center}

	\subsection{Constraints}

	To ensure \texttt{scheduling} consistency, the following constraints are made:
	\begin{itemize}
		\item \texttt{sum(scheduling) = N;} ensures that all the orders are fulfilled %and
		\item \texttt{forall(j in 1..N)(\\
			sum([scheduling[id,j,ih]| id in 1..d, ih in 1..h]) = 1\\
		  );} ensures that only one delivever takes care of one order. 
	\end{itemize}

	\paragraph*{}
	To construct the matrix \texttt{P} a simple product between a \texttt{scheduling} row and the array of the destinations \texttt{dest} is
	made:
	\begin{verbatim}
forall(id in 1..d, ih in 1..h, iN in 1..N)(
   P[id, iN, ih] = scheduling[id, iN, ih] * dest[iN]
);
	\end{verbatim}
	
	Thanks to this product, we are able to make meangingful the same positions
	as \texttt{scheduling}.

	\paragraph*{}
	The \texttt{X} matrix has to contain all the meaningful	positions in the matrix
	\texttt{P}. To ensure this, we need a simple way to sequentially compute all the
	informations related in a single row, so we push all the meaningless values (zeros)
	to the end of the row and, for every value greater than zero, found in a row of
	\texttt{P}, we enforce the corresponding row of \texttt{X} to contain it.

	\begin{verbatim}
forall(id in 1..d, ih in 1..h, iN in 1..N)(
   if P[id, iN, ih] > 0 then
      count([ X[id, iNN, ih] | iNN in 1..N] ,iN,1) 
   else
      count([ X[id, iNN, ih] | iNN in 1..N] ,iN,0)
   endif
   /\
   ( X[id,iN,ih]=0 -> forall(j in iN..N) (X[id,j,ih] = 0) )
);
	\end{verbatim}


	\paragraph*{}
	To compute distances means to fill the \texttt{distances} matrix.
    To do this, we have to use the matrix \texttt{X}. 
	Considering a single row, we must take care of the following cases:
	\begin{itemize}
		\item the first (meaningful) cell
		\item the other (meaningful) cells
	\end{itemize}
	
	In the first case, if \texttt{X[1]} is the first meaningful position in the 
	matrix P and \texttt{P[X[1]]} is the first visited node in a travel,
	the distance of the node \texttt{P[X[1]]} is computed summing the 
	distance between the pizzeria (node number 1) and this node (\texttt{mdist[1, P[X[1]]]}).
	This value is put in \texttt{distances[X[1]]}.\\
	
	In the last case, the distance to reach the node in \texttt{X[i]} is 
	the sum of the distance between the node \texttt{X[i]} and \texttt{X[i-1]}, and all 
	the distances previusly computed to reach the latter. 
    % TODO: DA SCRIVERE IN MATEMATICHESE!! COME DICE MINOOO!!! 
	\begin{verbatim}
forall(id in 1..d, iN in 1..N, ih in 1..h)(
   if X[id,iN,ih] !=0 then
      if iN == 1 then
         distances[id, X[id,iN,ih], ih] = 
            mdist[1, P[id, X[id,iN,ih], ih]] 
       else
          distances[id, X[id,iN,ih], ih] = 
            mdist[P[id, X[id,iN-1,ih], ih], P[id, X[id,iN,ih], ih]] 
         	+ sum([distances[id,P[id, X[id,iNN,ih], ih],ih]
                  | iNN in 1..iN-1])
       endif
   endif
);
	\end{verbatim}

	\paragraph*{}
	Moreover, using \texttt{X}, we must check the "travel consistency", which 
	means that the deliverer must be able to return back to the pizzeria before the 
	start of the next half-an-hour. 
	To do this, we implement the so called \textit{"hat condition"}. This condition 
	identify the last meangingful position in one row of the matrix \texttt{X}
	and enforce that, from that position, the sum of the distance to reach
	that node plus the distance to return back to the pizzeria is less than 30.

\begin{verbatim}
forall(id in 1..d, iN in 1..N, ih in 1..h)(
   if X[id,iN,ih] !=0 then
      if iN+1 == N+1 then
         distances[id, X[id,iN,ih], ih] 
            + mdist[P[id, X[id,iN,ih], ih],1] < 30
      else
         if X[id,iN+1,ih] == 0 then
            distances[id, X[id,iN,ih], ih] 
               + mdist[P[id, X[id,iN,ih], ih],1] < 30
         endif
      endif
   endif
);
\end{verbatim}

	\paragraph*{}
	To make \texttt{ea} consistent, which is the array that allow us to record the expected arrival
	time of each delivery, we take into account the row representing the delivery in the 
	\texttt{scheduling} matrix and the same position in the \texttt{distances} matrix. Since 
	\texttt{scheduling} is a boolean matrix, only the meaningful position in 
	\texttt{distances} will be used. To this value is added 30 for every half-an-hour passed,
	from the starting time to the beginning of the corresponding half-an-hour. 
	\begin{verbatim}
forall(j in 1..N)(
   ea[j] = sum([ scheduling[id,j,ih] 
                 * (distances[id,j,ih]+((ih-1)*30))
               | id in 1..d, ih in 1..h ])  
);
	\end{verbatim}

	In addition to the constraint seen before, the following enforce that every delivery
	in delivered within 30 minutes starting from the desired delivery time.
	\begin{verbatim}
forall(iN in 1..N)(
   ea[iN] >= ra[iN] /\ ea[iN] < ra[iN]+30 
);		  
	\end{verbatim}

	\paragraph*{}
	The consistency of \texttt{pizzas\_carried} is trivial. First of all, we check that
	the number of pizzas carried in the evening is equal to the number of total pizzas in the 
	orders. Than, for every order, we enforce that the number of pizzas carried by a deliverer 
	in one half-an-hour is the same as the number of pizzas in the orders that he/she 
	is taking care of in the same half-an-hour.
	\begin{verbatim}
sum(pizzas_carried) = sum(num_pizze);

forall(id in 1..d, ih in 1..h)(
   pizzas_carried[id, ih] = sum([ num_pizze[j]
                                | j in 1..N 
                                where scheduling[id, j, ih] = 1])
);
	\end{verbatim}

	\paragraph*{}
	Some of the data structures previously analized could have been avoided if we 
	wanted to have a more lightweight model. We introduced them to make simpler the
	creation of the constraint and to keep the model readable.
	% SCEGLIERE SE SCRIVERE CHE NON SAPPIAMO SE L'AUMENTO DELLE STRUTTURE CHE 
	% VENGONO UTILIZZATE NEL MODELLO POSSA AVER PEGGIORATO LE SUE PRESTAZIONI GLOBALI 

	\subsubsection{Euristichs}

	\begin{itemize}
		\item Nuovo taglio mezz'ore
	\end{itemize}

	Creating the model, we included some easy euristichs that can restrict the dimension
	of the search space. As seen before the delivery must take place in the 30-minutes delivery window
	that starts from the desired delivery time.\\
	This allows us to constrain the \texttt{scheduling} matrix to have zeros before
	and after the desired delivery window.
	\begin{verbatim}
forall(id in 1..d, iN in 1..N, ih in 1..h)(
  ( (ih*30) <= ra[iN] -> scheduling[id,iN,ih] = 0 )
  /\
  ( ((ih-1)*30) > (ra[iN]+15) -> scheduling[id,iN,ih] = 0 )
);
	\end{verbatim}

	\subsubsection{Simmetry breaking strategy}
	Having more than one deliverer implies the possibility of having the same solution 
	multiple times. For example, if we have three delivery and two deliverers, known that
	the best strategy is to deliver the first two togheter and the third alone, one solution is 
	to give the first two to the deliverer \texttt{d1} and the third to the deliverer \texttt{d2}.
	A simmetric and equivalent solution is to give the first two to \texttt{d2} and 
	the third to \texttt{d1}.

	In order to avoid this kind of problem, we impose an ordering on the deliverers by 
	counting the number of pizzas that are carried in one half-an-hour. This enforce that 
	the first deliverer carries a number of pizzas greater of equal to the number of
	pizzas carried by the second deliverer, the second deliverer a number of pizzas greater or 
	equal to the number of pizzas of the third deliverer and so on.
\begin{verbatim}
forall(ih in 1..h, id in 1..d-1)(
  pizzas_carried[id,ih] >= pizzas_carried[id+1,ih]
);
\end{verbatim}

	\section{Results}
	\label{Results}

	In this section, we will describe how the model behave, mainly in terms of solving
	time, using different input data and different search strategies.



	\paragraph*{}
	As said before, the data structures used in the model are, in somme way, redundant
	to have a better readability. We are not sure if having a lower number of data 
	structures and a more complex constraint generation would have made the model
	faster in finding the best solution.
	


	\section{Future work}
	\label{Future work}
	Only total travelled distance is minimized (for now). Maybe a balancing 
	function is needed or maybe not.

\end{document}



